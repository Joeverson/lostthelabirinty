package controllers;

import java.awt.List;
import java.util.Random;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter.DEFAULT;

import models.Exit;
import models.ObjectLabirinty;
import models.Warrior;
import models.wall;


public class GenerateLabirinty {
	protected static ObjectLabirinty[][] labirinties;
	//nivel de labirinto -- tamando do quadrado
	protected static int lvLabirinty;

	//localização do guerreiro
	protected static int x;
	protected static int y;

	private static Warrior warrior = new Warrior();

	//lista de comandos
	private static final String[] commandsSteps = {"left","right","top","bottom","leftTop","rightTop","bottomTop","bottomTop"}; 


	public GenerateLabirinty() {}

	//metodo para gerar o labirinto
	public static void generate(int i){
		lvLabirinty = i;
		labirinties = new ObjectLabirinty[i][i];

		for(int k = 0; k < i; k++){			
			for(int j = 0; j < i; j++){
				labirinties[k][j] = new ObjectLabirinty();
				
				if(k == 0 && j == 0){ //parte superior esquerdo
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderLeft(true);
					labirinties[k][j].setBorderTop(true);
				}else if(k == 0 && j == i){ //parte inferior esquerdo
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderLeft(true);
					labirinties[k][j].setBorderBottom(true);
				}else if(k == i && j == 0){ //parte inferior esquerdo
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderTop(true);
					labirinties[k][j].setBorderRight(true);
				}else if(k == i && j == i){ //parte inferior esquerdo
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderBottom(true);
					labirinties[k][j].setBorderRight(true);
				}else if(k == 0){ //parte lateral esquerda
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderLeft(true);
				}else if(j == 0){ //parte superior
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderTop(true);
				}else if(k == ( i - 1 )){ //parte lateral Direita
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderRight(true);
				}else if(j == ( i - 1 )){ //parte inferior
					labirinties[k][j].setBorder(true);
					labirinties[k][j].setBorderBottom(true);
				}
			}
		}

		// gerando paredes
		//addWall();

		//addExit();
		
		viewLab();
		
		// adiciona o jogador
		addWarrior(warrior);

		System.out.println("guerreiro esta no x = "+x);
		System.out.println("guerreiro esta no y = "+y);
	}


	//adicionar paredes
	public static void addWall(){
		int quantWallForLines = lvLabirinty/2;		
		Random rnd = new Random();
		System.out.println(lvLabirinty);

		for(int k = 0; k < lvLabirinty; k++){			
			for(int j = 0; j < quantWallForLines; j++){
				labirinties[k][rnd.nextInt(quantWallForLines)].setContaint(new wall());
			}
		}

	}

	//colocar player no jogo
	public static void addWarrior(Warrior w){
		Random rnd = new Random();
		
		while(true){
			x = rnd.nextInt(lvLabirinty);
			y = rnd.nextInt(lvLabirinty);
			
			if(labirinties[x][y].getContaint() == null){
				labirinties[x][y].setContaint(w);			

				break;
			}
			System.out.println("ocupado!!");// teste p tirar isso
		}
	}

	//colocar player no jogo
	public static void addExit(){
		Random rnd = new Random();
		int xExit;
		int yExit;

		while(true){
			xExit = rnd.nextInt(lvLabirinty);
			yExit = rnd.nextInt(lvLabirinty);

			if(labirinties[xExit][yExit].getContaint() == null){
				labirinties[xExit][yExit].setContaint(new Exit());
				break;
			}
		}
	}

	// para testes de visualizações
	public static void viewLab(){		
		for(int k = 0; k < lvLabirinty; k++){			
			for(int j = 0; j < lvLabirinty; j++){				
				if( (wall) labirinties[k][j].getContaint() != null){
					//System.out.println(((wall) labirinties[k][j].getContaint()).msg());
					System.out.println("Posições de x = "+k+" y = "+j);
				}

			}
		}
	}
	
	//chamada de acçoes de passos
	public static void steps(String steps){
		switch(steps){
			case "left":
				Move.goLeft(warrior);
				break;
			case "right":
				Move.goRight(warrior);
				break;
			case "top":
				Move.goTop(warrior);
				break;
			case "bottom":
				Move.goBottom(warrior);
				break;
			default:
				System.out.println("Comando invalido! \n\n");				
		}
	}


}
