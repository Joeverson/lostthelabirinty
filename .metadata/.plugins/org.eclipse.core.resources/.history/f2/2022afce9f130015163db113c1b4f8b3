package controllers;

import java.awt.List;
import java.util.Random;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter.DEFAULT;

import models.ObjectLabirinty;
import models.Warrior;
import models.wall;


public class GenerateLabirinty {
	private static ObjectLabirinty[][] labirinties;
	//nivel de labirinto -- tamando do quadrado
	private static int lvLabirinty;
	
	//localização do guerreiro
	private static int[] locationWarrior = new int[2];
	
	private static String warrior = "maria";
	
	//lista de comandos
	private static final String[] commandsSteps = {"left","right","top","bottom","leftTop","rightTop","bottomTop","bottomTop"}; 
	
	
	public GenerateLabirinty() {}
	
	//metodo para gerar o labirinto
	public static void generate(int i){
		lvLabirinty = i;
		labirinties = new ObjectLabirinty[i][i];
		
		for(int k = 0; k < i; k++){			
			for(int j = 0; j < i; j++){
				labirinties[k][j] = new ObjectLabirinty();
			}
		}
		
		// gerando paredes
		addWall();
		
		viewLab();
		
		// adiciona o jogador
		addWarrior(warrior);
		
		System.out.println("guerreiro esta no x = "+locationWarrior[0]);
		System.out.println("guerreiro esta no y = "+locationWarrior[1]);
	}
	
	
	//adicionar paredes
	public static void addWall(){
		int quantWallForLines = lvLabirinty/2;		
		Random rnd = new Random();
		System.out.println(quantWallForLines);
		
		for(int k = 0; k < lvLabirinty; k++){			
			for(int j = 0; j < quantWallForLines; j++){
				labirinties[rnd.nextInt(quantWallForLines)][rnd.nextInt(quantWallForLines)].setContaint(new wall());
			}
		}
		
	}
	
	//colocar player no jogo
	public static void addWarrior(String name){
		Random rnd = new Random();
		int x;
		int y;
		
		while(true){
			x = rnd.nextInt(lvLabirinty);
			y = rnd.nextInt(lvLabirinty);
			
			if(labirinties[x][y].getContaint() == null){
				labirinties[x][y].setContaint(new Warrior(x,y,name));
				
				//guardando localização de guerreiro
				locationWarrior[1] = x;
				locationWarrior[0] = y;
				
				break;
			}
		}
	}
	
	// para testes de visualizações
	public static void viewLab(){		
		for(int k = 0; k < lvLabirinty; k++){			
			for(int j = 0; j < lvLabirinty; j++){				
				if( (wall) labirinties[k][j].getContaint() != null){
					//System.out.println(((wall) labirinties[k][j].getContaint()).msg());
					System.out.println("Posições de x = "+k+" y = "+j);
				}
				
			}
		}
	}
	
	
	//chamada de acçoes de passos
	public static void steps(String steps){
		switch(steps){
			case "left":
				goLeft();
				break;
			case "right":
				goRight();
				break;
			case "top":
				goTop();
				break;
			case "bottom":
				goBottom();
				break;
			default:
				System.out.println("Comando invalido! \n de um dos seguintes comandos:\n\n");
			    for(int h = 0; h < commandsSteps.length; h++){
			    	System.out.println(" \t- "+commandsSteps[h]+"\n");
			    }
		}
	}
	
	
	// funções de navegação
	
	//left
	private static void goLeft(){
		Warrior w = (Warrior) labirinties[locationWarrior[0]][locationWarrior[1]].getContaint();
		int x = locationWarrior[0];
		int y = locationWarrior[1];
		
		if(labirinties[(x-1)][y].getContaint() == null){
			labirinties[x-1][y].setContaint(w);
			
			//deixa nulo a posição anterior do guerreiro
			labirinties[x][y].setContaint(null);
			
			locationWarrior[0] = x-1;
			
			System.out.println("guerreiro esta no x = "+locationWarrior[0]);
			System.out.println("guerreiro esta no y = "+locationWarrior[1]);
			
		}else{
			((wall) labirinties[x-1][y].getContaint()).msg();
		}
	}
	
	//right
		private static void goRight(){
			Warrior w = (Warrior) labirinties[locationWarrior[0]][locationWarrior[1]].getContaint();
			int x = locationWarrior[0];
			int y = locationWarrior[1];
			
			if(labirinties[(x+1)][y].getContaint() == null){
				labirinties[x+1][y].setContaint(w);
				
				//deixa nulo a posição anterior do guerreiro
				labirinties[x][y].setContaint(null);
				
				locationWarrior[0] = x+1;
				
				System.out.println("guerreiro esta no x = "+locationWarrior[0]);
				System.out.println("guerreiro esta no y = "+locationWarrior[1]);
				
			}else{
				System.out.println("parede");
			}
		}
		
		//top
			private static void goTop(){
				Warrior w = (Warrior) labirinties[locationWarrior[0]][locationWarrior[1]].getContaint();
				int x = locationWarrior[0];
				int y = locationWarrior[1];
					
				if(labirinties[(x)][y-1].getContaint() == null){
					labirinties[x][y-1].setContaint(w);
						
					//deixa nulo a posição anterior do guerreiro
					labirinties[x][y].setContaint(null);
						
					locationWarrior[1] = y-1;
						
					System.out.println("guerreiro esta no x = "+locationWarrior[0]);
					System.out.println("guerreiro esta no y = "+locationWarrior[1]);
						
				}else{
					System.out.println("parede");
				}
			}
			
			
			//bottom
			private static void goBottom(){
				Warrior w = (Warrior) labirinties[locationWarrior[0]][locationWarrior[1]].getContaint();
				int x = locationWarrior[0];
				int y = locationWarrior[1];
					
				if(labirinties[(x)][y+1].getContaint() == null){
					labirinties[x][y+1].setContaint(w);
						
					//deixa nulo a posição anterior do guerreiro
					labirinties[x][y].setContaint(null);
						
					locationWarrior[1] = y+1;
						
					System.out.println("guerreiro esta no x = "+locationWarrior[0]);
					System.out.println("guerreiro esta no y = "+locationWarrior[1]);
						
				}else{
					((wall) labirinties[x][y+1].getContaint()).msg();
				}
			}

}
